<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>System Design | The Mize Collection</title><meta name=keywords content="system-design"><meta name=description content="Introduction
The goal of system design is to architect scalable, reliable, maintainable, and performant software systems that meet both functional and non-functional requirements.
It focuses on how components (databases, APIs, caches, queues) interact, scale under load, recover from failure, and handle growth.
System design balances trade-offs (like CAP theorem, latency vs. throughput, consistency vs. availability) to ensure the system performs well under real-world constraints.
The art of turning product specs into robust architecture that can scale, survive, and evolve."><meta name=author content><link rel=canonical href=https://mizerc.github.io/posts/eng-system-design/><script async src="https://www.googletagmanager.com/gtag/js?id=G-NSFZNK7SSK"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-NSFZNK7SSK")</script><link crossorigin=anonymous href=/assets/css/stylesheet.446cc608fb2eeca040e3f550f79b21a7de7b97859101459113eb3325853e12ce.css integrity="sha256-RGzGCPsu7KBA4/VQ95shp957l4WRAUWRE+szJYU+Es4=" rel="preload stylesheet" as=style><link rel=icon href=https://mizerc.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://mizerc.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://mizerc.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://mizerc.github.io/apple-touch-icon.png><link rel=mask-icon href=https://mizerc.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://mizerc.github.io/posts/eng-system-design/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css integrity=sha384-5TcZemv2l/9On385z///+d7MSYlvIEw9FuZTIdZ14vJLqWphw7e7ZPuOiCHJcFCP crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js integrity=sha384-cMkvdD8LoxVzGF/RPUKAcvmm49FQ0oxwDF3BGKtDXcEc+T1b2N+teh/OJfpU0jr6 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js integrity=sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh crossorigin=anonymous></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],throwOnError:!1})})</script><meta property="og:url" content="https://mizerc.github.io/posts/eng-system-design/"><meta property="og:site_name" content="The Mize Collection"><meta property="og:title" content="System Design"><meta property="og:description" content="Introduction The goal of system design is to architect scalable, reliable, maintainable, and performant software systems that meet both functional and non-functional requirements. It focuses on how components (databases, APIs, caches, queues) interact, scale under load, recover from failure, and handle growth. System design balances trade-offs (like CAP theorem, latency vs. throughput, consistency vs. availability) to ensure the system performs well under real-world constraints. The art of turning product specs into robust architecture that can scale, survive, and evolve."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-06-01T00:00:00+00:00"><meta property="article:modified_time" content="2024-06-01T00:00:00+00:00"><meta property="article:tag" content="System-Design"><meta name=twitter:card content="summary"><meta name=twitter:title content="System Design"><meta name=twitter:description content="Introduction
The goal of system design is to architect scalable, reliable, maintainable, and performant software systems that meet both functional and non-functional requirements.
It focuses on how components (databases, APIs, caches, queues) interact, scale under load, recover from failure, and handle growth.
System design balances trade-offs (like CAP theorem, latency vs. throughput, consistency vs. availability) to ensure the system performs well under real-world constraints.
The art of turning product specs into robust architecture that can scale, survive, and evolve."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://mizerc.github.io/posts/"},{"@type":"ListItem","position":2,"name":"System Design","item":"https://mizerc.github.io/posts/eng-system-design/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"System Design","name":"System Design","description":"Introduction The goal of system design is to architect scalable, reliable, maintainable, and performant software systems that meet both functional and non-functional requirements. It focuses on how components (databases, APIs, caches, queues) interact, scale under load, recover from failure, and handle growth. System design balances trade-offs (like CAP theorem, latency vs. throughput, consistency vs. availability) to ensure the system performs well under real-world constraints. The art of turning product specs into robust architecture that can scale, survive, and evolve.\n","keywords":["system-design"],"articleBody":"Introduction The goal of system design is to architect scalable, reliable, maintainable, and performant software systems that meet both functional and non-functional requirements. It focuses on how components (databases, APIs, caches, queues) interact, scale under load, recover from failure, and handle growth. System design balances trade-offs (like CAP theorem, latency vs. throughput, consistency vs. availability) to ensure the system performs well under real-world constraints. The art of turning product specs into robust architecture that can scale, survive, and evolve.\nHow to approach a system design problem Understand requirements: Functional (product features) + non-functional (scalability, latency, availability, consistency).\nDefine scalability targets: What scale do we need? (users/sec, data volume, request rate).\nDefine the system architecture:\nLoad balancing: Horizontal scaling via stateless services + load balancers. Observability: Metrics, logging, tracing to monitor scale and detect bottlenecks. Data management: Use scalable storage (NoSQL, sharded RDBMS), cache frequently accessed data (CDN, in-memory cache):\nData partitioning: Sharding, replication, and consistency. Asynchronous processing: Offload heavy tasks to background workers, queues.\nFault tolerance: Redundancy, failover, and recovery.\nSecurity: Authentication, authorization, and encryption.\nCost optimization: Resource allocation, billing, and monitoring.\nParts Load Balancer Load Balancer is a component that distributes incoming traffic across multiple servers, aka, it is a traffic distributor. Ensures scalability, fault tolerance, and availability.\nExample tools: NGINX.\nStrategies:\nRound-robin (even distribution) Least connections (fewest connections) Least response time (lowest latency) Hash (consistent hashing) IP hash (same IP to same server, session stickiness) Weighted (based on server capacity) Reverse Proxy It is a frontend gateway. Sits in front of servers, forwards client requests to appropriate backend. Example tools: NGINX.\nRate Limiting Rate Limiting is a technique to limit the number of requests a client can make to a server. It can be configured in NGIX or glued to a controller/service in the application layer using a middleware and Redis.\nExample tools: Redis, NGINX.\nCircuit Breakers Circuit Breakers are used to protect a system from cascading failures.\nCache Cache is a component that stores frequently accessed data to improve performance. For example, we could use Redis to cache frequently accessed data that would otherwise be fetched from a database which could be slow for a large number of requests.\nHit rate (% of requests served from cache), low hit rate =\u003e cache miss =\u003e potential performance bottleneck. Latency (response time to client), if cache hit =\u003e fast (e.g. \u003c 1 ms in Redis), if cache miss =\u003e slow (database retrieval, \u003e100 ms). Message Queue Message Queue enables asynchronous communication and allow us to decouple services. It’s a key component for building scalable and fault-tolerant systems. It’s also a key component for building event-driven or microservices architectures.\nJob Queue Job Queue is a special case of message queuing. It usually involves enqueuing units of work (jobs/tasks) that need to be processed. For Node.js applicatgigons, we can use BullMQ library to implement job queue.\nScaling Vertical Scaling Vertical scaling involves increasing the resources (CPU, memory, storage) of a single server.\nHorizontal Scaling Horizontal scaling involves adding more servers to handle the load. It is more scalable, but requires entering the world of distributed system and handling techniques such as:\nLoad balancing Data partitioning Fault tolerance Asynchronous processing Caching Database sharding Queues CDN Common Bottlenecks N+1 Queries Network Calls Reduce rounds trip.\nMemory Leak Your O(1) time and space logic will not help if the implementation is causing a memory leak.\nData Volume Burst Data volume can increase rapidly, 10x in a day. Can be caused by flash sale, campaign, etc.\nHow to Detect\nSpikes in latency only on specific partitions. Disk/CPU saturation on one node but not others. High replication lag on one replica. Database Replication Replication involves creating multiple copies of the data on different servers. Improve fault tolerance and availability.\nPartitioning Data partitioning involves dividing the data into smaller chunks and storing them on different servers.\nBad shard keys =\u003e Potential shard hotspots =\u003e Performance bottleneck. For example, if we shard a table by user ID, and the user ID is not evenly distributed, then some shards will have more data than others (write hotspots).\nCAP Theorem The CAP theorem, also named Brewer’s theorem, states that a distributed system can only have two of the following three properties:\nConsistency Availability Partition tolerance ","wordCount":"705","inLanguage":"en","datePublished":"2024-06-01T00:00:00Z","dateModified":"2024-06-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://mizerc.github.io/posts/eng-system-design/"},"publisher":{"@type":"Organization","name":"The Mize Collection","logo":{"@type":"ImageObject","url":"https://mizerc.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><link rel=stylesheet href=https://mizerc.github.io/custom.css><header class=header><nav class=nav><div class=logo><a href=https://mizerc.github.io/ accesskey=h title="The Mize Collection (Alt + H)">The Mize Collection</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://mizerc.github.io/ title=Home><span>Home</span></a></li><li><a href=https://mizerc.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">System Design</h1><hr></header><div class=post-content><h1 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h1><p>The goal of system design is to architect scalable, reliable, maintainable, and performant software systems that meet both functional and non-functional requirements.
It focuses on how components (databases, APIs, caches, queues) interact, scale under load, recover from failure, and handle growth.
System design balances trade-offs (like CAP theorem, latency vs. throughput, consistency vs. availability) to ensure the system performs well under real-world constraints.
The art of turning product specs into robust architecture that can scale, survive, and evolve.</p><h1 id=how-to-approach-a-system-design-problem>How to approach a system design problem<a hidden class=anchor aria-hidden=true href=#how-to-approach-a-system-design-problem>#</a></h1><ol><li><p>Understand requirements: Functional (product features) + non-functional (scalability, latency, availability, consistency).</p></li><li><p>Define scalability targets: What scale do we need? (users/sec, data volume, request rate).</p></li><li><p>Define the system architecture:</p><ul><li>Load balancing: Horizontal scaling via stateless services + load balancers.</li><li>Observability: Metrics, logging, tracing to monitor scale and detect bottlenecks.</li></ul></li><li><p>Data management: Use scalable storage (NoSQL, sharded RDBMS), cache frequently accessed data (CDN, in-memory cache):</p><ul><li>Data partitioning: Sharding, replication, and consistency.</li></ul></li><li><p>Asynchronous processing: Offload heavy tasks to background workers, queues.</p></li><li><p>Fault tolerance: Redundancy, failover, and recovery.</p></li><li><p>Security: Authentication, authorization, and encryption.</p></li><li><p>Cost optimization: Resource allocation, billing, and monitoring.</p></li></ol><h1 id=parts>Parts<a hidden class=anchor aria-hidden=true href=#parts>#</a></h1><h2 id=load-balancer>Load Balancer<a hidden class=anchor aria-hidden=true href=#load-balancer>#</a></h2><p>Load Balancer is a component that distributes incoming traffic across multiple servers, aka, it is a traffic distributor.
Ensures scalability, fault tolerance, and availability.</p><p>Example tools: NGINX.</p><p>Strategies:</p><ul><li>Round-robin (even distribution)</li><li>Least connections (fewest connections)</li><li>Least response time (lowest latency)</li><li>Hash (consistent hashing)</li><li>IP hash (same IP to same server, session stickiness)</li><li>Weighted (based on server capacity)</li></ul><h2 id=reverse-proxy>Reverse Proxy<a hidden class=anchor aria-hidden=true href=#reverse-proxy>#</a></h2><p>It is a frontend gateway.
Sits in front of servers, forwards client requests to appropriate backend.
Example tools: NGINX.</p><h2 id=rate-limiting>Rate Limiting<a hidden class=anchor aria-hidden=true href=#rate-limiting>#</a></h2><p>Rate Limiting is a technique to limit the number of requests a client can make to a server.
It can be configured in NGIX or glued to a controller/service in the application layer using a middleware and Redis.</p><p>Example tools: Redis, NGINX.</p><h2 id=circuit-breakers>Circuit Breakers<a hidden class=anchor aria-hidden=true href=#circuit-breakers>#</a></h2><p>Circuit Breakers are used to protect a system from cascading failures.</p><h2 id=cache>Cache<a hidden class=anchor aria-hidden=true href=#cache>#</a></h2><p>Cache is a component that stores frequently accessed data to improve performance.
For example, we could use Redis to cache frequently accessed data that would otherwise be fetched from a database which could be slow for a large number of requests.</p><ul><li>Hit rate (% of requests served from cache), low hit rate => cache miss => potential performance bottleneck.</li><li>Latency (response time to client), if cache hit => fast (e.g. &lt; 1 ms in Redis), if cache miss => slow (database retrieval, >100 ms).</li></ul><h2 id=message-queue>Message Queue<a hidden class=anchor aria-hidden=true href=#message-queue>#</a></h2><p>Message Queue enables asynchronous communication and allow us to decouple services.
It&rsquo;s a key component for building scalable and fault-tolerant systems.
It&rsquo;s also a key component for building event-driven or microservices architectures.</p><h2 id=job-queue>Job Queue<a hidden class=anchor aria-hidden=true href=#job-queue>#</a></h2><p>Job Queue is a special case of message queuing.
It usually involves enqueuing units of work (jobs/tasks) that need to be processed.
For Node.js applicatgigons, we can use BullMQ library to implement job queue.</p><h1 id=scaling>Scaling<a hidden class=anchor aria-hidden=true href=#scaling>#</a></h1><h2 id=vertical-scaling>Vertical Scaling<a hidden class=anchor aria-hidden=true href=#vertical-scaling>#</a></h2><p>Vertical scaling involves increasing the resources (CPU, memory, storage) of a single server.</p><h2 id=horizontal-scaling>Horizontal Scaling<a hidden class=anchor aria-hidden=true href=#horizontal-scaling>#</a></h2><p>Horizontal scaling involves adding more servers to handle the load.
It is more scalable, but requires entering the world of <code>distributed system</code> and handling techniques such as:</p><ul><li>Load balancing</li><li>Data partitioning</li><li>Fault tolerance</li><li>Asynchronous processing</li><li>Caching</li><li>Database sharding</li><li>Queues</li><li>CDN</li></ul><h1 id=common-bottlenecks>Common Bottlenecks<a hidden class=anchor aria-hidden=true href=#common-bottlenecks>#</a></h1><h2 id=n1-queries>N+1 Queries<a hidden class=anchor aria-hidden=true href=#n1-queries>#</a></h2><h2 id=network-calls>Network Calls<a hidden class=anchor aria-hidden=true href=#network-calls>#</a></h2><p>Reduce rounds trip.</p><h2 id=memory-leak>Memory Leak<a hidden class=anchor aria-hidden=true href=#memory-leak>#</a></h2><p>Your O(1) time and space logic will not help if the implementation is causing a memory leak.</p><h2 id=data-volume-burst>Data Volume Burst<a hidden class=anchor aria-hidden=true href=#data-volume-burst>#</a></h2><p>Data volume can increase rapidly, 10x in a day.
Can be caused by flash sale, campaign, etc.</p><p>How to Detect</p><ul><li>Spikes in latency only on specific partitions.</li><li>Disk/CPU saturation on one node but not others.</li><li>High replication lag on one replica.</li></ul><h1 id=database>Database<a hidden class=anchor aria-hidden=true href=#database>#</a></h1><h2 id=replication>Replication<a hidden class=anchor aria-hidden=true href=#replication>#</a></h2><p>Replication involves creating multiple copies of the data on different servers.
Improve fault tolerance and availability.</p><h2 id=partitioning>Partitioning<a hidden class=anchor aria-hidden=true href=#partitioning>#</a></h2><p>Data partitioning involves dividing the data into smaller chunks and storing them on different servers.</p><p>Bad shard keys => Potential shard hotspots => Performance bottleneck.
For example, if we shard a table by user ID, and the user ID is not evenly distributed, then some shards will have more data than others (write hotspots).</p><h1 id=cap-theorem>CAP Theorem<a hidden class=anchor aria-hidden=true href=#cap-theorem>#</a></h1><p>The CAP theorem, also named Brewer&rsquo;s theorem, states that a distributed system can only have two of the following three properties:</p><ul><li>Consistency</li><li>Availability</li><li>Partition tolerance</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://mizerc.github.io/tags/system-design/>System-Design</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://mizerc.github.io/>The Mize Collection</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>