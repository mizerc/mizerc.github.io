<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Microcontrollers & 3D Graphics | The Mize Collection</title><meta name=keywords content="microproject"><meta name=description content="In this micro project, the objective is to utilize a microcontroller paired with a display to render a rotating 3D cube and evaluate its performance capabilities.
Arduino Nano
The Arduino Nano is a small board using the 328P microcontroller, offering USB, I2C, SPI communication.

     
            Arduino Nano front.
        



     
            Arduino Nano back.
        


The CH340

     
            CH340 chip.
        


The CH340 is a USB to serial converter chip.
It allows devices to be programmed and controlled via a USB connection, eliminating the need for a separate &ldquo;programmer&rdquo; device."><meta name=author content><link rel=canonical href=https://mizerc.github.io/posts/projects/iot-microcontroller-n-3d-graphics/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://mizerc.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://mizerc.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://mizerc.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://mizerc.github.io/apple-touch-icon.png><link rel=mask-icon href=https://mizerc.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://mizerc.github.io/posts/projects/iot-microcontroller-n-3d-graphics/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://mizerc.github.io/posts/projects/iot-microcontroller-n-3d-graphics/"><meta property="og:site_name" content="The Mize Collection"><meta property="og:title" content="Microcontrollers & 3D Graphics"><meta property="og:description" content="In this micro project, the objective is to utilize a microcontroller paired with a display to render a rotating 3D cube and evaluate its performance capabilities.
Arduino Nano The Arduino Nano is a small board using the 328P microcontroller, offering USB, I2C, SPI communication.
Arduino Nano front.
Arduino Nano back.
The CH340 CH340 chip.
The CH340 is a USB to serial converter chip. It allows devices to be programmed and controlled via a USB connection, eliminating the need for a separate “programmer” device."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-02T00:00:00+00:00"><meta property="article:modified_time" content="2025-03-02T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Microcontrollers & 3D Graphics"><meta name=twitter:description content="In this micro project, the objective is to utilize a microcontroller paired with a display to render a rotating 3D cube and evaluate its performance capabilities.
Arduino Nano
The Arduino Nano is a small board using the 328P microcontroller, offering USB, I2C, SPI communication.

     
            Arduino Nano front.
        



     
            Arduino Nano back.
        


The CH340

     
            CH340 chip.
        


The CH340 is a USB to serial converter chip.
It allows devices to be programmed and controlled via a USB connection, eliminating the need for a separate &ldquo;programmer&rdquo; device."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://mizerc.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Microcontrollers \u0026 3D Graphics","item":"https://mizerc.github.io/posts/projects/iot-microcontroller-n-3d-graphics/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Microcontrollers \u0026 3D Graphics","name":"Microcontrollers \u0026 3D Graphics","description":"In this micro project, the objective is to utilize a microcontroller paired with a display to render a rotating 3D cube and evaluate its performance capabilities.\nArduino Nano The Arduino Nano is a small board using the 328P microcontroller, offering USB, I2C, SPI communication.\nArduino Nano front.\nArduino Nano back.\nThe CH340 CH340 chip.\nThe CH340 is a USB to serial converter chip. It allows devices to be programmed and controlled via a USB connection, eliminating the need for a separate \u0026ldquo;programmer\u0026rdquo; device.\n","keywords":["microproject"],"articleBody":"In this micro project, the objective is to utilize a microcontroller paired with a display to render a rotating 3D cube and evaluate its performance capabilities.\nArduino Nano The Arduino Nano is a small board using the 328P microcontroller, offering USB, I2C, SPI communication.\nArduino Nano front.\nArduino Nano back.\nThe CH340 CH340 chip.\nThe CH340 is a USB to serial converter chip. It allows devices to be programmed and controlled via a USB connection, eliminating the need for a separate “programmer” device.\nThe 328P Microcontroller The 328P microcontroller.\nThe ATmega328 is a single-chip microcontroller created by Atmel in the megaAVR family.\nThe AVR is a family of microcontrollers developed since 1996 by Atmel. They are 8-bit RISC single-chip microcontrollers based on a modified Harvard architecture. AVR was one of the first microcontroller families to use on-chip FLASH memory for program storage, as opposed to one-time programmable ROM, EPROM, or EEPROM used by other microcontrollers at the time.\nDisplay The display uses the ST7735 driver.\nThe display has 8 pins: LED, SCK, SDA, A0, RESET, CS, GND, VCC.\nThe A0 pin is the data/command PIN, it is a control pin that tells the display whether the data sent over SPI is a command or pixel data.\nThe LED pin is for the backlight power. The light behind the display.\nSCK, SDA, and CS are part of the SPI communication. SDA is the MISO. I’m not sure why the display label as SDA instead of MISO. We are not using MOSI since the display never send data to the nano.\nIn SPI communication (which your Arduino uses for the display), MOSI (Master Out Slave In) is the line where the Arduino (the master) sends data out to the display (the slave).\nWiring The wiring between the Nano and the display requires cables for the SPI communication (clock, miso and cs), power (LED, GND and VCC), as well as 2 extra for control and reset.\nDisplay PIN Arduino PIN LED 5V SCK D13 (SPI SCK) SDA D11 (SPI MOSI) A0 D8 (DC) RESET D9 CS D10 GND GND VCC 5V Raster We first need to define the 8 vertex in a 3d space. We want the cartesian coordinates to be at the center of the cube. We can imagine a cube going from -1 to +1 for each x, y and z axis.\nPhotos As the cube rotates and the camera approximates, the number of pixels to raster changes. And we can notice that the longer the number of screen pixels to raster, the long it takes to render a single frame.\nNext Steps Done Instead of erasing the entire screen each frame, we can erase only the lines of the previous frame. Next Features:\nImplemnt a camera look at matrix. Try to raster a filled cube. Try to use triangles like it is done in modern raster engines. Perfomance:\nUsing only integer instead of floating points in algorithms. Try to find assembly instructions that perfoms better. Modify the library to remove any unecessary instructions. If we have more than 1 core, we can keep one doing rasterization and the other one doing SPI communication with the screen. ","wordCount":"526","inLanguage":"en","datePublished":"2025-03-02T00:00:00Z","dateModified":"2025-03-02T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://mizerc.github.io/posts/projects/iot-microcontroller-n-3d-graphics/"},"publisher":{"@type":"Organization","name":"The Mize Collection","logo":{"@type":"ImageObject","url":"https://mizerc.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://mizerc.github.io/ accesskey=h title="The Mize Collection (Alt + H)">The Mize Collection</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://mizerc.github.io/ title=Home><span>Home</span></a></li><li><a href=https://mizerc.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Microcontrollers & 3D Graphics</h1></header><div class=post-content><p>In this micro project, the objective is to utilize a microcontroller paired with a display to render a rotating 3D cube and evaluate its performance capabilities.</p><h2 id=arduino-nano>Arduino Nano<a hidden class=anchor aria-hidden=true href=#arduino-nano>#</a></h2><p>The Arduino Nano is a small board using the 328P microcontroller, offering USB, I2C, SPI communication.</p><figure><img loading=lazy src=./photos/nano-front.png#center alt="Arduino Nano front." width=90%><figcaption><p>Arduino Nano front.</p></figcaption></figure><figure><img loading=lazy src=./photos/nano-back.png#center alt="Arduino Nano back." width=90%><figcaption><p>Arduino Nano back.</p></figcaption></figure><h3 id=the-ch340>The CH340<a hidden class=anchor aria-hidden=true href=#the-ch340>#</a></h3><figure><img loading=lazy src=./photos/ch340.png#center alt="CH340 chip." width=90%><figcaption><p>CH340 chip.</p></figcaption></figure><p>The CH340 is a USB to serial converter chip.
It allows devices to be programmed and controlled via a USB connection, eliminating the need for a separate &ldquo;programmer&rdquo; device.</p><h3 id=the-328p-microcontroller>The 328P Microcontroller<a hidden class=anchor aria-hidden=true href=#the-328p-microcontroller>#</a></h3><figure><img loading=lazy src=./photos/320p.png#center alt="The 328P microcontroller." width=90%><figcaption><p>The 328P microcontroller.</p></figcaption></figure><p>The ATmega328 is a single-chip microcontroller created by Atmel in the megaAVR family.</p><p>The AVR is a family of microcontrollers developed since 1996 by Atmel.
They are 8-bit RISC single-chip microcontrollers based on a modified Harvard architecture.
AVR was one of the first microcontroller families to use on-chip FLASH memory for program storage, as opposed to one-time programmable ROM, EPROM, or EEPROM used by other microcontrollers at the time.</p><h2 id=display>Display<a hidden class=anchor aria-hidden=true href=#display>#</a></h2><p>The display uses the ST7735 driver.</p><p>The display has 8 pins: LED, SCK, SDA, A0, RESET, CS, GND, VCC.</p><p>The A0 pin is the data/command PIN, it is a control pin that tells the display whether the data sent over SPI is a command or pixel data.</p><p>The LED pin is for the backlight power.
The light behind the display.</p><p>SCK, SDA, and CS are part of the SPI communication.
SDA is the MISO.
I&rsquo;m not sure why the display label as SDA instead of MISO.
We are not using MOSI since the display never send data to the nano.</p><p>In SPI communication (which your Arduino uses for the display), MOSI (Master Out Slave In) is the line where the Arduino (the master) sends data out to the display (the slave).</p><h2 id=wiring>Wiring<a hidden class=anchor aria-hidden=true href=#wiring>#</a></h2><p>The wiring between the Nano and the display requires cables for the SPI communication (clock, miso and cs), power (LED, GND and VCC), as well as 2 extra for control and reset.</p><table><thead><tr><th>Display PIN</th><th>Arduino PIN</th></tr></thead><tbody><tr><td>LED</td><td>5V</td></tr><tr><td>SCK</td><td>D13 (SPI SCK)</td></tr><tr><td>SDA</td><td>D11 (SPI MOSI)</td></tr><tr><td>A0</td><td>D8 (DC)</td></tr><tr><td>RESET</td><td>D9</td></tr><tr><td>CS</td><td>D10</td></tr><tr><td>GND</td><td>GND</td></tr><tr><td>VCC</td><td>5V</td></tr></tbody></table><h2 id=raster>Raster<a hidden class=anchor aria-hidden=true href=#raster>#</a></h2><p>We first need to define the 8 vertex in a 3d space.
We want the cartesian coordinates to be at the center of the cube.
We can imagine a cube going from -1 to +1 for each x, y and z axis.</p><h2 id=photos>Photos<a hidden class=anchor aria-hidden=true href=#photos>#</a></h2><figure><img loading=lazy src=./photos/ss1.png#center width=90%></figure><figure><img loading=lazy src=./photos/video1.gif#center width=90%></figure><p>As the cube rotates and the camera approximates, the number of pixels to raster changes.
And we can notice that the longer the number of screen pixels to raster, the long it takes to render a single frame.</p><h1 id=next-steps>Next Steps<a hidden class=anchor aria-hidden=true href=#next-steps>#</a></h1><h2 id=done>Done<a hidden class=anchor aria-hidden=true href=#done>#</a></h2><ul><li>Instead of erasing the entire screen each frame, we can erase only the lines of the previous frame.</li></ul><h2 id=next>Next<a hidden class=anchor aria-hidden=true href=#next>#</a></h2><p>Features:</p><ul><li>Implemnt a camera look at matrix.</li><li>Try to raster a filled cube.</li><li>Try to use triangles like it is done in modern raster engines.</li></ul><p>Perfomance:</p><ul><li>Using only integer instead of floating points in algorithms.</li><li>Try to find assembly instructions that perfoms better.</li><li>Modify the library to remove any unecessary instructions.</li><li>If we have more than 1 core, we can keep one doing rasterization and the other one doing SPI communication with the screen.</li></ul></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://mizerc.github.io/>The Mize Collection</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>