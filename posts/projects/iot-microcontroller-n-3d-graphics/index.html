<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Microcontrollers & 3D Graphics | The Mize Collection</title><meta name=keywords content="microproject"><meta name=description content="In this micro project, the objective is to utilize a microcontroller paired with a display to render a rotating 3D cube and evaluate its performance capabilities.
Hardware
Arduino Nano
The Arduino Nano is a small board that uses the 328P microcontroller, offering IO ports (digital in/out (0-5V), analog in/out (ADC, PWM), Serial, I2C, SPI), voltage regulator (LM1117, 7-12V in), and USB communication thru the CH340 chip and a Mini-B usb port."><meta name=author content><link rel=canonical href=https://mizerc.github.io/posts/projects/iot-microcontroller-n-3d-graphics/><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://mizerc.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://mizerc.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://mizerc.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://mizerc.github.io/apple-touch-icon.png><link rel=mask-icon href=https://mizerc.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://mizerc.github.io/posts/projects/iot-microcontroller-n-3d-graphics/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-NSFZNK7SSK"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-NSFZNK7SSK")</script><meta property="og:url" content="https://mizerc.github.io/posts/projects/iot-microcontroller-n-3d-graphics/"><meta property="og:site_name" content="The Mize Collection"><meta property="og:title" content="Microcontrollers & 3D Graphics"><meta property="og:description" content="In this micro project, the objective is to utilize a microcontroller paired with a display to render a rotating 3D cube and evaluate its performance capabilities.
Hardware Arduino Nano The Arduino Nano is a small board that uses the 328P microcontroller, offering IO ports (digital in/out (0-5V), analog in/out (ADC, PWM), Serial, I2C, SPI), voltage regulator (LM1117, 7-12V in), and USB communication thru the CH340 chip and a Mini-B usb port."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-02T00:00:00+00:00"><meta property="article:modified_time" content="2025-03-02T00:00:00+00:00"><meta property="article:tag" content="Microproject"><meta name=twitter:card content="summary"><meta name=twitter:title content="Microcontrollers & 3D Graphics"><meta name=twitter:description content="In this micro project, the objective is to utilize a microcontroller paired with a display to render a rotating 3D cube and evaluate its performance capabilities.
Hardware
Arduino Nano
The Arduino Nano is a small board that uses the 328P microcontroller, offering IO ports (digital in/out (0-5V), analog in/out (ADC, PWM), Serial, I2C, SPI), voltage regulator (LM1117, 7-12V in), and USB communication thru the CH340 chip and a Mini-B usb port."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://mizerc.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Microcontrollers \u0026 3D Graphics","item":"https://mizerc.github.io/posts/projects/iot-microcontroller-n-3d-graphics/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Microcontrollers \u0026 3D Graphics","name":"Microcontrollers \u0026 3D Graphics","description":"In this micro project, the objective is to utilize a microcontroller paired with a display to render a rotating 3D cube and evaluate its performance capabilities.\nHardware Arduino Nano The Arduino Nano is a small board that uses the 328P microcontroller, offering IO ports (digital in/out (0-5V), analog in/out (ADC, PWM), Serial, I2C, SPI), voltage regulator (LM1117, 7-12V in), and USB communication thru the CH340 chip and a Mini-B usb port.\n","keywords":["microproject"],"articleBody":"In this micro project, the objective is to utilize a microcontroller paired with a display to render a rotating 3D cube and evaluate its performance capabilities.\nHardware Arduino Nano The Arduino Nano is a small board that uses the 328P microcontroller, offering IO ports (digital in/out (0-5V), analog in/out (ADC, PWM), Serial, I2C, SPI), voltage regulator (LM1117, 7-12V in), and USB communication thru the CH340 chip and a Mini-B usb port.\nArduino Nano front.\nArduino Nano back.\nThe 328P Microcontroller The 328P microcontroller.\nThe ATmega328 is a single-chip microcontroller created by Atmel in the megaAVR family.\nThe AVR is a family of microcontrollers developed since 1996 by Atmel. They are 8-bit RISC single-chip microcontrollers based on a modified Harvard architecture. AVR was one of the first microcontroller families to use on-chip FLASH memory for program storage, as opposed to one-time programmable ROM, EPROM, or EEPROM used by other microcontrollers at the time.\nThe CH340 CH340 chip.\nThe CH340 is a USB to serial converter chip. It allows devices to be programmed and controlled via a USB connection, eliminating the need for a separate “programmer” device.\nThe 3.3V pin of the arduino nano is coming from the output of the CH340 pin.\nOther boards may uses different chip like the FT232RL or CP2102.\nThe 1117 chip On the left of the previous photo, we can also see the 1117 voltage regulator chip. Not that the VIN pin goes to the regulator input first, but the 5V pin don’t.\nDisplay The display uses the ST7735 driver.\nThe display has 8 pins: LED, SCK, SDA, A0, RESET, CS, GND, VCC.\nThe A0 pin is the data/command PIN, it is a control pin that tells the display whether the data sent over SPI is a command or pixel data.\nThe LED pin is for the backlight power. The light behind the display.\nSCK, SDA, and CS are part of the SPI communication. SDA is the MISO. I’m not sure why the display label as SDA instead of MISO. We are not using MOSI since the display never send data to the nano.\nIn SPI communication (which your Arduino uses for the display), MOSI (Master Out Slave In) is the line where the Arduino (the master) sends data out to the display (the slave).\nWiring The wiring between the Nano and the display requires cables for the SPI communication (clock, miso and cs), power (LED, GND and VCC), as well as 2 extra for control and reset.\nDisplay PIN Arduino PIN GND GND VCC 5V LED 5V SCK D13 (SPI SCK) SDA D11 (SPI MOSI) CS D10 (SPI Chip Select) A0 D8 (Data/Command) RESET D9 The datasheet of the Arduino Nano metions that we should not drawn more than 20mA from the pin.\nSoftware To be able to draw the cube on the little screen, we need to find a way to represent the cube in memory, apply a few transformation, then project and finally raster.\nCube We first need to define the 8 vertex in a 3d space. We want the cartesian coordinates to be at the center of the cube. We can imagine a cube going from -1 to +1 for each x, y and z axis.\nThe positive z axis goes towards the screen.\nFront (z=-1)\n1 2 3 4 v0 = \u003c-1, +1, -1\u003e v1 = \u003c+1, +1, -1\u003e v2 = \u003c+1, -1, -1\u003e v3 = \u003c-1, -1, -1\u003e Back (z=+1)\n1 2 3 4 v0 = \u003c-1, +1, +1\u003e v1 = \u003c+1, +1, +1\u003e v2 = \u003c+1, -1, +1\u003e v3 = \u003c-1, -1, +1\u003e Cube in memory using C We can define a Vec3 as array of 3 floats to store each coordinate.\n1 2 3 typedef Vec3 [] Cube3D cube; cube[0][1] = +1; // v0.y = +1 Matrices Next we need to build a few matrices to allow us to transform each vertex in space.\ntranslate scale rotate_x rotate_y rotate_z Projection Finally we need to compute the position of each vertex on the 2d screen. We can use a simple perspective division to make points far away smaller.\n1 2 cube2d.x = cube3d.x / cube3d.z cube2d.y = cube3d.y / cube3d.z Rasterization Now that we have the position of each 2d point on the screen. We need to raster the line from p1 to p2 of each cube edge. To proper see the cube, we want to raster lines from the following vertexes:\nv0 to v1 v1 to v2 v1 to v2 Manually defining each origin and destination to rasterize a line is no fun. I realized this might be why graphics pipelines opted for a more generic approach: using triangles. There, everything is modeled using triangles. And the entire graphics pipeline is ready to process them.\nOverview 1 2 3 4 5 6 7 8 9 10 11 12 raw_cube = load_cube() for each vertex v of raw_cube: scale() rotate_x() rotate_y() rotate_z() translate() cube2d = project() raster: line(v0, v1) Result As the cube rotates and the camera approximates, the number of pixels to raster changes. And we can notice that the longer the number of screen pixels to raster, the long it takes to render a single frame.\nDone Perfomance:\nInstead of erasing the entire screen each frame, we can erase only the lines drawn in the last frames. Future Work Features:\nImplement a camera look_at matrix. Try to raster a filled cube or even a texturized cube. Try to use triangles like it is done in modern raster engines. Perfomance:\nUsing only integer instead of floating points in algorithms. Try to find assembly instructions that perfoms better. Modify the library to remove any unecessary instructions. If we have more than 1 core, we can keep one doing rasterization and the other one doing SPI communication with the screen. Engineering:\nImplement my own graphics library instead of using the GFX library. ","wordCount":"972","inLanguage":"en","datePublished":"2025-03-02T00:00:00Z","dateModified":"2025-03-02T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://mizerc.github.io/posts/projects/iot-microcontroller-n-3d-graphics/"},"publisher":{"@type":"Organization","name":"The Mize Collection","logo":{"@type":"ImageObject","url":"https://mizerc.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://mizerc.github.io/ accesskey=h title="The Mize Collection (Alt + H)">The Mize Collection</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://mizerc.github.io/ title=Home><span>Home</span></a></li><li><a href=https://mizerc.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://mizerc.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Microcontrollers & 3D Graphics</h1></header><div class=post-content><p>In this micro project, the objective is to utilize a microcontroller paired with a display to render a rotating 3D cube and evaluate its performance capabilities.</p><h2 id=hardware>Hardware<a hidden class=anchor aria-hidden=true href=#hardware>#</a></h2><h3 id=arduino-nano>Arduino Nano<a hidden class=anchor aria-hidden=true href=#arduino-nano>#</a></h3><p>The Arduino Nano is a small <strong>board</strong> that uses the 328P microcontroller, offering IO ports (digital in/out (0-5V), analog in/out (ADC, PWM), Serial, I2C, SPI), voltage regulator (LM1117, 7-12V in), and USB communication thru the CH340 chip and a Mini-B usb port.</p><figure><img loading=lazy src=./photos/nano-front.png#center alt="Arduino Nano front." width=70%><figcaption><p>Arduino Nano front.</p></figcaption></figure><figure><img loading=lazy src=./photos/nano-back.png#center alt="Arduino Nano back." width=70%><figcaption><p>Arduino Nano back.</p></figcaption></figure><h4 id=the-328p-microcontroller>The 328P Microcontroller<a hidden class=anchor aria-hidden=true href=#the-328p-microcontroller>#</a></h4><figure><img loading=lazy src=./photos/mega328p.png#center alt="The 328P microcontroller." width=70%><figcaption><p>The 328P microcontroller.</p></figcaption></figure><p>The ATmega328 is a single-chip microcontroller created by Atmel in the megaAVR family.</p><p>The AVR is a family of microcontrollers developed since 1996 by Atmel.
They are 8-bit RISC single-chip microcontrollers based on a modified Harvard architecture.
AVR was one of the first microcontroller families to use on-chip FLASH memory for program storage, as opposed to one-time programmable ROM, EPROM, or EEPROM used by other microcontrollers at the time.</p><h4 id=the-ch340>The CH340<a hidden class=anchor aria-hidden=true href=#the-ch340>#</a></h4><figure><img loading=lazy src=./photos/ch340.png#center alt="CH340 chip." width=70%><figcaption><p>CH340 chip.</p></figcaption></figure><p>The CH340 is a USB to serial converter chip.
It allows devices to be programmed and controlled via a USB connection, eliminating the need for a separate &ldquo;programmer&rdquo; device.</p><p>The 3.3V pin of the arduino nano is coming from the output of the CH340 pin.</p><p>Other boards may uses different chip like the FT232RL or CP2102.</p><h4 id=the-1117-chip>The 1117 chip<a hidden class=anchor aria-hidden=true href=#the-1117-chip>#</a></h4><p>On the left of the previous photo, we can also see the 1117 voltage regulator chip.
Not that the VIN pin goes to the regulator input first, but the 5V pin don&rsquo;t.</p><h3 id=display>Display<a hidden class=anchor aria-hidden=true href=#display>#</a></h3><p>The display uses the ST7735 driver.</p><p>The display has 8 pins: LED, SCK, SDA, A0, RESET, CS, GND, VCC.</p><p>The A0 pin is the data/command PIN, it is a control pin that tells the display whether the data sent over SPI is a command or pixel data.</p><p>The LED pin is for the backlight power.
The light behind the display.</p><p>SCK, SDA, and CS are part of the SPI communication.
SDA is the MISO.
I&rsquo;m not sure why the display label as SDA instead of MISO.
We are not using MOSI since the display never send data to the nano.</p><p>In SPI communication (which your Arduino uses for the display), MOSI (Master Out Slave In) is the line where the Arduino (the master) sends data out to the display (the slave).</p><p><figure><img loading=lazy src=./photos/display-front.png#center width=50%></figure><figure><img loading=lazy src=./photos/display-back.png#center width=50%></figure></p><h3 id=wiring>Wiring<a hidden class=anchor aria-hidden=true href=#wiring>#</a></h3><p>The wiring between the Nano and the display requires cables for the SPI communication (clock, miso and cs), power (LED, GND and VCC), as well as 2 extra for control and reset.</p><table><thead><tr><th>Display PIN</th><th>Arduino PIN</th></tr></thead><tbody><tr><td>GND</td><td>GND</td></tr><tr><td>VCC</td><td>5V</td></tr><tr><td>LED</td><td>5V</td></tr><tr><td>SCK</td><td>D13 (SPI SCK)</td></tr><tr><td>SDA</td><td>D11 (SPI MOSI)</td></tr><tr><td>CS</td><td>D10 (SPI Chip Select)</td></tr><tr><td>A0</td><td>D8 (Data/Command)</td></tr><tr><td>RESET</td><td>D9</td></tr></tbody></table><p>The datasheet of the Arduino Nano metions that we should not drawn more than 20mA from the pin.</p><h2 id=software>Software<a hidden class=anchor aria-hidden=true href=#software>#</a></h2><p>To be able to draw the cube on the little screen, we need to find a way to represent the cube in memory, apply a few transformation, then project and finally raster.</p><h3 id=cube>Cube<a hidden class=anchor aria-hidden=true href=#cube>#</a></h3><p>We first need to define the 8 vertex in a 3d space.
We want the cartesian coordinates to be at the center of the cube.
We can imagine a cube going from -1 to +1 for each x, y and z axis.</p><p>The positive z axis goes towards the screen.</p><p>Front (z=-1)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>v0</span> <span class=o>=</span> <span class=o>&lt;-</span><span class=mi>1</span><span class=p>,</span> <span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=nx>v1</span> <span class=o>=</span> <span class=o>&lt;+</span><span class=mi>1</span><span class=p>,</span> <span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=nx>v2</span> <span class=o>=</span> <span class=o>&lt;+</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=nx>v3</span> <span class=o>=</span> <span class=o>&lt;-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=o>&gt;</span>
</span></span></code></pre></td></tr></table></div></div><p>Back (z=+1)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>v0</span> <span class=o>=</span> <span class=o>&lt;-</span><span class=mi>1</span><span class=p>,</span> <span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=o>+</span><span class=mi>1</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=nx>v1</span> <span class=o>=</span> <span class=o>&lt;+</span><span class=mi>1</span><span class=p>,</span> <span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=o>+</span><span class=mi>1</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=nx>v2</span> <span class=o>=</span> <span class=o>&lt;+</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>+</span><span class=mi>1</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=nx>v3</span> <span class=o>=</span> <span class=o>&lt;-</span><span class=mi>1</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=o>+</span><span class=mi>1</span><span class=o>&gt;</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=cube-in-memory-using-c>Cube in memory using C<a hidden class=anchor aria-hidden=true href=#cube-in-memory-using-c>#</a></h3><p>We can define a Vec3 as array of 3 floats to store each coordinate.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=n>Vec3</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl><span class=n>Cube3D</span> <span class=n>cube</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>cube</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=o>+</span><span class=mi>1</span><span class=p>;</span> <span class=c1>// v0.y = +1
</span></span></span></code></pre></td></tr></table></div></div><h3 id=matrices>Matrices<a hidden class=anchor aria-hidden=true href=#matrices>#</a></h3><p>Next we need to build a few matrices to allow us to transform each vertex in space.</p><h4 id=translate>translate<a hidden class=anchor aria-hidden=true href=#translate>#</a></h4><h4 id=scale>scale<a hidden class=anchor aria-hidden=true href=#scale>#</a></h4><h4 id=rotate_x>rotate_x<a hidden class=anchor aria-hidden=true href=#rotate_x>#</a></h4><h4 id=rotate_y>rotate_y<a hidden class=anchor aria-hidden=true href=#rotate_y>#</a></h4><h4 id=rotate_z>rotate_z<a hidden class=anchor aria-hidden=true href=#rotate_z>#</a></h4><h3 id=projection>Projection<a hidden class=anchor aria-hidden=true href=#projection>#</a></h3><p>Finally we need to compute the position of each vertex on the 2d screen.
We can use a simple perspective division to make points far away smaller.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>cube2d</span><span class=p>.</span><span class=n>x</span> <span class=o>=</span> <span class=n>cube3d</span><span class=p>.</span><span class=n>x</span> <span class=o>/</span> <span class=n>cube3d</span><span class=p>.</span><span class=n>z</span>
</span></span><span class=line><span class=cl><span class=n>cube2d</span><span class=p>.</span><span class=n>y</span> <span class=o>=</span> <span class=n>cube3d</span><span class=p>.</span><span class=n>y</span> <span class=o>/</span> <span class=n>cube3d</span><span class=p>.</span><span class=n>z</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=rasterization>Rasterization<a hidden class=anchor aria-hidden=true href=#rasterization>#</a></h3><p>Now that we have the position of each 2d point on the screen.
We need to raster the line from p1 to p2 of each cube edge.
To proper see the cube, we want to raster lines from the following vertexes:</p><ul><li>v0 to v1</li><li>v1 to v2</li><li>v1 to v2</li></ul><p>Manually defining each origin and destination to rasterize a line is no fun.
I realized this might be why graphics pipelines opted for a more generic approach: using triangles.
There, everything is modeled using triangles.
And the entire graphics pipeline is ready to process them.</p><h3 id=overview>Overview<a hidden class=anchor aria-hidden=true href=#overview>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>raw_cube</span> <span class=o>=</span> <span class=nx>load_cube</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=nx>each</span> <span class=nx>vertex</span> <span class=nx>v</span> <span class=k>of</span> <span class=nx>raw_cube</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nx>scale</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>rotate_x</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>rotate_y</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>rotate_z</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>translate</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>cube2d</span> <span class=o>=</span> <span class=nx>project</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>raster</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=nx>line</span><span class=p>(</span><span class=nx>v0</span><span class=p>,</span> <span class=nx>v1</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=result>Result<a hidden class=anchor aria-hidden=true href=#result>#</a></h3><figure><img loading=lazy src=./photos/ss1.png#center width=90%></figure><figure><img loading=lazy src=./photos/video1.gif#center width=90%></figure><p>As the cube rotates and the camera approximates, the number of pixels to raster changes.
And we can notice that the longer the number of screen pixels to raster, the long it takes to render a single frame.</p><h4 id=done>Done<a hidden class=anchor aria-hidden=true href=#done>#</a></h4><p>Perfomance:</p><ul><li>Instead of erasing the entire screen each frame, we can erase only the lines drawn in the last frames.</li></ul><h4 id=future-work>Future Work<a hidden class=anchor aria-hidden=true href=#future-work>#</a></h4><p>Features:</p><ul><li>Implement a camera look_at matrix.</li><li>Try to raster a filled cube or even a texturized cube.</li><li>Try to use triangles like it is done in modern raster engines.</li></ul><p>Perfomance:</p><ul><li>Using only integer instead of floating points in algorithms.</li><li>Try to find assembly instructions that perfoms better.</li><li>Modify the library to remove any unecessary instructions.</li><li>If we have more than 1 core, we can keep one doing rasterization and the other one doing SPI communication with the screen.</li></ul><p>Engineering:</p><ul><li>Implement my own graphics library instead of using the GFX library.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://mizerc.github.io/tags/microproject/>Microproject</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://mizerc.github.io/>The Mize Collection</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>