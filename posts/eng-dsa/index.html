<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>DSA | The Mize Collection</title>
<meta name="keywords" content="">
<meta name="description" content="Introduction
DSA stands for Data Structures and Algorithms.
Linear Containers
A linear container is a type of data structure where elements are arranged in a linear order, which each element has a unique predecessor and successor, except the first and last items.
We can use the term List to refer the interface that define the operations that can be performed on it.
And let the term like Array, Queue, Linked List, etc. to refer to the specific implementation of the List interface.
Each implementation has its own advantages and disadvantages.">
<meta name="author" content="">
<link rel="canonical" href="https://example.org/posts/eng-dsa/">


<script async src="https://www.googletagmanager.com/gtag/js?id=G-NSFZNK7SSK"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NSFZNK7SSK');
</script>
<link crossorigin="anonymous" href="/assets/css/stylesheet.c99e5cfcb9fc753351f74fbc922b84fc6fc938d5bc8196bd1cc0121a2f2ca665.css" integrity="sha256-yZ5c/Ln8dTNR90&#43;8kiuE/G/JONW8gZa9HMASGi8spmU=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://example.org/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://example.org/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://example.org/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://example.org/apple-touch-icon.png">
<link rel="mask-icon" href="https://example.org/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://example.org/posts/eng-dsa/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css" integrity="sha384-5TcZemv2l/9On385z///+d7MSYlvIEw9FuZTIdZ14vJLqWphw7e7ZPuOiCHJcFCP" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js" integrity="sha384-cMkvdD8LoxVzGF/RPUKAcvmm49FQ0oxwDF3BGKtDXcEc+T1b2N+teh/OJfpU0jr6" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>
<meta property="og:url" content="https://example.org/posts/eng-dsa/">
  <meta property="og:site_name" content="The Mize Collection">
  <meta property="og:title" content="DSA">
  <meta property="og:description" content="Introduction DSA stands for Data Structures and Algorithms.
Linear Containers A linear container is a type of data structure where elements are arranged in a linear order, which each element has a unique predecessor and successor, except the first and last items.
We can use the term List to refer the interface that define the operations that can be performed on it. And let the term like Array, Queue, Linked List, etc. to refer to the specific implementation of the List interface. Each implementation has its own advantages and disadvantages.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-05-21T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-05-21T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="DSA">
<meta name="twitter:description" content="Introduction
DSA stands for Data Structures and Algorithms.
Linear Containers
A linear container is a type of data structure where elements are arranged in a linear order, which each element has a unique predecessor and successor, except the first and last items.
We can use the term List to refer the interface that define the operations that can be performed on it.
And let the term like Array, Queue, Linked List, etc. to refer to the specific implementation of the List interface.
Each implementation has its own advantages and disadvantages.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://example.org/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "DSA",
      "item": "https://example.org/posts/eng-dsa/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "DSA",
  "name": "DSA",
  "description": "Introduction DSA stands for Data Structures and Algorithms.\nLinear Containers A linear container is a type of data structure where elements are arranged in a linear order, which each element has a unique predecessor and successor, except the first and last items.\nWe can use the term List to refer the interface that define the operations that can be performed on it. And let the term like Array, Queue, Linked List, etc. to refer to the specific implementation of the List interface. Each implementation has its own advantages and disadvantages.\n",
  "keywords": [
    
  ],
  "articleBody": "Introduction DSA stands for Data Structures and Algorithms.\nLinear Containers A linear container is a type of data structure where elements are arranged in a linear order, which each element has a unique predecessor and successor, except the first and last items.\nWe can use the term List to refer the interface that define the operations that can be performed on it. And let the term like Array, Queue, Linked List, etc. to refer to the specific implementation of the List interface. Each implementation has its own advantages and disadvantages.\nAbout memory layout, each element could be sequentially layed in memory (contiguous memory allocation like in Array) or not contiguous (like in Linked List). Having a contiguous memory allocation allows O(1) access time to elements using address arithmetic. The downside is that the size of the container is fixed, requiring a resize operation if the container is full. Which can be amortized to O(1) if the resize operation is done in a factor of 2 (twice the current size).\nLinked list allow us to grow the container without the need to resize the underlying array. Each new element is allocated in the heap memory and linked to the next/previous element using a pointer. A linked list can be single or double linked. It also can contain a reference to the first (head) and last element (tail).\nAnother structures like Queue and Stack are special cases of List. They have constraints on the operations/behavior that can be performed on them. For example, a Stack implements the LIFO (Last In First Out) policy, and often expose the push and pop operations where the push operation adds an element to the top of the stack and the pop operation removes the top element from the stack, respecting the LIFO policy.\nA Queue implements the FIFO (First In First Out) policy, and often expose the enqueue and dequeue operations where the enqueue operation adds an element to the back of the queue and the dequeue operation removes the front element from the queue, respecting the FIFO policy.\nA Deque is a double ended queue, which allows the insertion and removal of elements from both ends. It normally exposses methods like push_front, push_back, pop_front, and pop_back.\nArray Static Array (Fixed size) Dynamic Array (Growable) List Single Linked List Double Linked List Circular Linked List Queue A queue is a linear container that follows the FIFO (First In First Out) policy. If you insert 1, then 2, then 3, then dequeue, you will get 1, then 2, then 3. The first element inserted is the first element to be removed. The last element inserted is the last element to be removed.\nA priority queue is a queue in which each element has a priority. The element with the highest priority is the first element to be removed. The element with the lowest priority is the last element to be removed. A priority queue can be implemented using a binary heap or sorting an array by priority.\nA circular queue is a queue in which the last element is connected to the first element. You can stop inserting once you fill the queue. Or keep inserting and overwriting the first elements.\nStack Implement the LIFO (Last In First Out) policy. If you insert 1, then 2, then 3, then pop, you will get 3, then 2, then 1. The first element inserted is the last element to be removed. The last element inserted is the first element to be removed.\nDeque Nom-Linear Containers Non-linear containers are data structures that do not follow a linear order, where each element can have multiple predecessors and successors.\nTrees A binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child. It is a special case of a tree where each node has at most two children. The root is the topmost node of the tree. The leaves are the nodes that do not have any children. The height of a tree is the number of edges on the longest path from the root to a leaf. The depth of a node is the number of edges from the root to the node.\nA binary search tree is a binary tree in which the value of each node’s left child is less than the node’s value, and the value of each node’s right child is greater than the node’s value. A balanced binary tree offer O(log n) for the insert, delete, and search operation.\nOftern we want to keep the tree balanced, so that the height of the tree is minimized. This avoid the worst case scenario of O(n) for the search operation like having a tree with only one branch.\nWe can keep the tree balanced by rebalancing the tree after each insertion or deletion. Some of the algorithms to keep the tree balanced are: AVL Tree, Red-Black Tree.\nImplementations:\nBinary Tree Binary Search Tree AVL Tree Red-Black Tree B-Tree B+Tree Trie Graphs A Graph is a more general data structure that can be used to represent a variety of relationships between objects. It is a collection of nodes (vertices) and edges (connections) between them.\nA directed graph is a graph in which the edges have a direction, ie, A -\u003e B, meaning that the edges can only be traversed in one direction. A undirected graph is a graph in which the edges do not have a direction, ie, A - B, meaning that the edges can be traversed in both directions.\nA weighted graph is a graph in which the edges have a weight/cost. A unweighted graph is a graph in which the edges do not have a weight/cost. Algortim like Dijkstra’s Algorithm requires a weighted graph to compute the shortest path.\nA cyclic graph is a graph in which there is a path that starts and ends at the same node. A acyclic graph is a graph in which there is no path that starts and ends at the same node.\nA connected graph is a graph in which there is a path between any two nodes. A disconnected graph is a graph in which there is no path between any two nodes.\nDirected Graph Undirected Graph Weighted Graph Unweighted Graph Heap Min Heap Max Heap Hash-based Hash Map Sets Union Find Disjoint Set Algorithms Sorting Bubble Sort Selection Sort Insertion Sort Merge Sort Quick Sort Heap Sort Merge Sort Recursively split the array into two halves until we have arrays of size 1. Then merge the two halves back together in a sorted manner.\nSearching Linear Search Binary Search Graph Algorithms Binary Search Tree Breadth-First Search (BFS) Depth-First Search (DFS) Dijkstra’s Algorithm Kruskal’s Algorithm Prim’s Algorithm Graph Coloring Travelling Salesman Problem Hamiltonian Cycle Minimum Spanning Tree Strategies Brute Force Greedy Divide and Conquer Dynamic Programming Famous Problems Two Sum Longest Substring Without Repeating Characters Longest Palindromic Substring 2d Grid Paths ",
  "wordCount" : "1160",
  "inLanguage": "en",
  "datePublished": "2025-05-21T00:00:00Z",
  "dateModified": "2025-05-21T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://example.org/posts/eng-dsa/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "The Mize Collection",
    "logo": {
      "@type": "ImageObject",
      "url": "https://example.org/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<link rel="stylesheet" href="https://example.org/custom.css">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://example.org/" accesskey="h" title="The Mize Collection (Alt + H)">The Mize Collection</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://example.org/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://example.org/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      DSA
    </h1>
    <hr>
  </header> 
  <div class="post-content"><h1 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h1>
<p>DSA stands for Data Structures and Algorithms.</p>
<h1 id="linear-containers">Linear Containers<a hidden class="anchor" aria-hidden="true" href="#linear-containers">#</a></h1>
<p>A linear container is a type of data structure where elements are arranged in a linear order, which each element has a unique predecessor and successor, except the first and last items.</p>
<p>We can use the term <code>List</code> to refer the interface that define the operations that can be performed on it.
And let the term like <code>Array</code>, <code>Queue</code>, <code>Linked List</code>, etc. to refer to the specific implementation of the <code>List</code> interface.
Each implementation has its own advantages and disadvantages.</p>
<p>About memory layout, each element could be sequentially layed in memory (contiguous memory allocation like in <code>Array</code>) or not contiguous (like in <code>Linked List</code>).
Having a contiguous memory allocation allows O(1) access time to elements using address arithmetic.
The downside is that the size of the container is fixed, requiring a resize operation if the container is full.
Which can be amortized to O(1) if the resize operation is done in a factor of 2 (twice the current size).</p>
<p>Linked list allow us to grow the container without the need to resize the underlying array.
Each new element is allocated in the heap memory and linked to the next/previous element using a pointer.
A linked list can be single or double linked.
It also can contain a reference to the first (head) and last element (tail).</p>
<p>Another structures like <code>Queue</code> and <code>Stack</code> are special cases of <code>List</code>.
They have constraints on the operations/behavior that can be performed on them.
For example, a Stack implements the LIFO (Last In First Out) policy, and often expose the <code>push</code> and <code>pop</code> operations where the <code>push</code> operation adds an element to the top of the stack and the <code>pop</code> operation removes the top element from the stack, respecting the LIFO policy.</p>
<p>A Queue implements the FIFO (First In First Out) policy, and often expose the <code>enqueue</code> and <code>dequeue</code> operations where the <code>enqueue</code> operation adds an element to the back of the queue and the <code>dequeue</code> operation removes the front element from the queue, respecting the FIFO policy.</p>
<p>A <code>Deque</code> is a double ended queue, which allows the insertion and removal of elements from both ends.
It normally exposses methods like <code>push_front</code>, <code>push_back</code>, <code>pop_front</code>, and <code>pop_back</code>.</p>
<h2 id="array">Array<a hidden class="anchor" aria-hidden="true" href="#array">#</a></h2>
<ul>
<li>Static Array (Fixed size)</li>
<li>Dynamic Array (Growable)</li>
</ul>
<h2 id="list">List<a hidden class="anchor" aria-hidden="true" href="#list">#</a></h2>
<ul>
<li>Single Linked List</li>
<li>Double Linked List</li>
<li>Circular Linked List</li>
</ul>
<h2 id="queue">Queue<a hidden class="anchor" aria-hidden="true" href="#queue">#</a></h2>
<p>A queue is a linear container that follows the FIFO (First In First Out) policy.
If you insert 1, then 2, then 3, then dequeue, you will get 1, then 2, then 3.
The first element inserted is the first element to be removed.
The last element inserted is the last element to be removed.</p>
<p>A priority queue is a queue in which each element has a priority.
The element with the highest priority is the first element to be removed.
The element with the lowest priority is the last element to be removed.
A priority queue can be implemented using a binary heap or sorting an array by priority.</p>
<p>A circular queue is a queue in which the last element is connected to the first element.
You can stop inserting once you fill the queue.
Or keep inserting and overwriting the first elements.</p>
<h2 id="stack">Stack<a hidden class="anchor" aria-hidden="true" href="#stack">#</a></h2>
<p>Implement the LIFO (Last In First Out) policy.
If you insert 1, then 2, then 3, then pop, you will get 3, then 2, then 1.
The first element inserted is the last element to be removed.
The last element inserted is the first element to be removed.</p>
<h2 id="deque">Deque<a hidden class="anchor" aria-hidden="true" href="#deque">#</a></h2>
<h1 id="nom-linear-containers">Nom-Linear Containers<a hidden class="anchor" aria-hidden="true" href="#nom-linear-containers">#</a></h1>
<p>Non-linear containers are data structures that do not follow a linear order, where each element can have multiple predecessors and successors.</p>
<h2 id="trees">Trees<a hidden class="anchor" aria-hidden="true" href="#trees">#</a></h2>
<p>A <code>binary tree</code> is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child. It is a special case of a tree where each node has at most two children.
The root is the topmost node of the tree.
The leaves are the nodes that do not have any children.
The height of a tree is the number of edges on the longest path from the root to a leaf.
The depth of a node is the number of edges from the root to the node.</p>
<p>A <code>binary search tree</code> is a binary tree in which the value of each node&rsquo;s left child is less than the node&rsquo;s value, and the value of each node&rsquo;s right child is greater than the node&rsquo;s value.
A balanced binary tree offer O(log n) for the insert, delete, and search operation.</p>
<p>Oftern we want to keep the tree balanced, so that the height of the tree is minimized.
This avoid the worst case scenario of O(n) for the search operation like having a tree with only one branch.</p>
<p><img alt="unbalenced-tree" loading="lazy" src="/posts/eng-dsa/images/unbalenced-tree.png#center"></p>
<p>We can keep the tree balanced by rebalancing the tree after each insertion or deletion.
Some of the algorithms to keep the tree balanced are: AVL Tree, Red-Black Tree.</p>
<p>Implementations:</p>
<ul>
<li>Binary Tree</li>
<li>Binary Search Tree</li>
<li>AVL Tree</li>
<li>Red-Black Tree</li>
<li>B-Tree</li>
<li>B+Tree</li>
<li>Trie</li>
</ul>
<h2 id="graphs">Graphs<a hidden class="anchor" aria-hidden="true" href="#graphs">#</a></h2>
<p>A Graph is a more general data structure that can be used to represent a variety of relationships between objects.
It is a collection of nodes (vertices) and edges (connections) between them.</p>
<p>A <code>directed graph</code> is a graph in which the edges have a direction, ie, A -&gt; B, meaning that the edges can only be traversed in one direction.
A <code>undirected graph</code> is a graph in which the edges do not have a direction, ie, A - B, meaning that the edges can be traversed in both directions.</p>
<p>A <code>weighted graph</code> is a graph in which the edges have a weight/cost.
A <code>unweighted graph</code> is a graph in which the edges do not have a weight/cost.
Algortim like Dijkstra&rsquo;s Algorithm requires a weighted graph to compute the shortest path.</p>
<p>A <code>cyclic graph</code> is a graph in which there is a path that starts and ends at the same node.
A <code>acyclic graph</code> is a graph in which there is no path that starts and ends at the same node.</p>
<p>A <code>connected graph</code> is a graph in which there is a path between any two nodes.
A <code>disconnected graph</code> is a graph in which there is no path between any two nodes.</p>
<ul>
<li>Directed Graph</li>
<li>Undirected Graph</li>
<li>Weighted Graph</li>
<li>Unweighted Graph</li>
</ul>
<h1 id="heap">Heap<a hidden class="anchor" aria-hidden="true" href="#heap">#</a></h1>
<ul>
<li>Min Heap</li>
<li>Max Heap</li>
</ul>
<h2 id="hash-based">Hash-based<a hidden class="anchor" aria-hidden="true" href="#hash-based">#</a></h2>
<ul>
<li>Hash Map</li>
</ul>
<h2 id="sets">Sets<a hidden class="anchor" aria-hidden="true" href="#sets">#</a></h2>
<ul>
<li>Union Find</li>
<li>Disjoint Set</li>
</ul>
<h1 id="algorithms">Algorithms<a hidden class="anchor" aria-hidden="true" href="#algorithms">#</a></h1>
<h2 id="sorting">Sorting<a hidden class="anchor" aria-hidden="true" href="#sorting">#</a></h2>
<ul>
<li>Bubble Sort</li>
<li>Selection Sort</li>
<li>Insertion Sort</li>
<li>Merge Sort</li>
<li>Quick Sort</li>
<li>Heap Sort</li>
</ul>
<h3 id="merge-sort">Merge Sort<a hidden class="anchor" aria-hidden="true" href="#merge-sort">#</a></h3>
<p>Recursively split the array into two halves until we have arrays of size 1.
Then merge the two halves back together in a sorted manner.</p>
<h2 id="searching">Searching<a hidden class="anchor" aria-hidden="true" href="#searching">#</a></h2>
<ul>
<li>Linear Search</li>
<li>Binary Search</li>
</ul>
<h2 id="graph-algorithms">Graph Algorithms<a hidden class="anchor" aria-hidden="true" href="#graph-algorithms">#</a></h2>
<ul>
<li>Binary Search Tree</li>
<li>Breadth-First Search (BFS)</li>
<li>Depth-First Search (DFS)</li>
<li>Dijkstra&rsquo;s Algorithm</li>
<li>Kruskal&rsquo;s Algorithm</li>
<li>Prim&rsquo;s Algorithm</li>
<li>Graph Coloring</li>
<li>Travelling Salesman Problem</li>
<li>Hamiltonian Cycle</li>
<li>Minimum Spanning Tree</li>
</ul>
<h1 id="strategies">Strategies<a hidden class="anchor" aria-hidden="true" href="#strategies">#</a></h1>
<ul>
<li>Brute Force</li>
<li>Greedy</li>
<li>Divide and Conquer</li>
<li>Dynamic Programming</li>
</ul>
<h1 id="famous-problems">Famous Problems<a hidden class="anchor" aria-hidden="true" href="#famous-problems">#</a></h1>
<ul>
<li>Two Sum</li>
<li>Longest Substring Without Repeating Characters</li>
<li>Longest Palindromic Substring</li>
<li>2d Grid Paths</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://example.org/">The Mize Collection</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
