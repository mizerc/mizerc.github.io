<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>WebGL | The Mize Collection</title>
<meta name="keywords" content="">
<meta name="description" content="Canvas
The HTML5 &lt;canvas&gt; element provides a drawable region in a web page that can be manipulated with JavaScript.
Context
The canvas object allow us to access two type of API or &lsquo;context&rsquo;.
The context2d which uses the CanvasRenderingContext2D API allow us to draw shapes, text, images, and perform pixel manipulation in a rasterized space.
The webgl which exposes a low-level WebGL API that allows direct access to the GPU for high-performance, hardware-accelerated rendering of 2D and 3D graphics.">
<meta name="author" content="">
<link rel="canonical" href="https://mizerc.github.io/posts/technology/webgl/">


<script async src="https://www.googletagmanager.com/gtag/js?id=G-NSFZNK7SSK"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NSFZNK7SSK');
</script>
<link crossorigin="anonymous" href="/assets/css/stylesheet.c99e5cfcb9fc753351f74fbc922b84fc6fc938d5bc8196bd1cc0121a2f2ca665.css" integrity="sha256-yZ5c/Ln8dTNR90&#43;8kiuE/G/JONW8gZa9HMASGi8spmU=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://mizerc.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://mizerc.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://mizerc.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://mizerc.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://mizerc.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://mizerc.github.io/posts/technology/webgl/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css" integrity="sha384-5TcZemv2l/9On385z///+d7MSYlvIEw9FuZTIdZ14vJLqWphw7e7ZPuOiCHJcFCP" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js" integrity="sha384-cMkvdD8LoxVzGF/RPUKAcvmm49FQ0oxwDF3BGKtDXcEc+T1b2N+teh/OJfpU0jr6" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          
          
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          
          throwOnError : false
        });
    });
</script>
<meta property="og:url" content="https://mizerc.github.io/posts/technology/webgl/">
  <meta property="og:site_name" content="The Mize Collection">
  <meta property="og:title" content="WebGL">
  <meta property="og:description" content="Canvas The HTML5 &lt;canvas&gt; element provides a drawable region in a web page that can be manipulated with JavaScript.
Context The canvas object allow us to access two type of API or ‘context’.
The context2d which uses the CanvasRenderingContext2D API allow us to draw shapes, text, images, and perform pixel manipulation in a rasterized space.
The webgl which exposes a low-level WebGL API that allows direct access to the GPU for high-performance, hardware-accelerated rendering of 2D and 3D graphics.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-05-21T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-05-21T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="WebGL">
<meta name="twitter:description" content="Canvas
The HTML5 &lt;canvas&gt; element provides a drawable region in a web page that can be manipulated with JavaScript.
Context
The canvas object allow us to access two type of API or &lsquo;context&rsquo;.
The context2d which uses the CanvasRenderingContext2D API allow us to draw shapes, text, images, and perform pixel manipulation in a rasterized space.
The webgl which exposes a low-level WebGL API that allows direct access to the GPU for high-performance, hardware-accelerated rendering of 2D and 3D graphics.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://mizerc.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "WebGL",
      "item": "https://mizerc.github.io/posts/technology/webgl/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "WebGL",
  "name": "WebGL",
  "description": "Canvas The HTML5 \u0026lt;canvas\u0026gt; element provides a drawable region in a web page that can be manipulated with JavaScript.\nContext The canvas object allow us to access two type of API or \u0026lsquo;context\u0026rsquo;.\nThe context2d which uses the CanvasRenderingContext2D API allow us to draw shapes, text, images, and perform pixel manipulation in a rasterized space.\nThe webgl which exposes a low-level WebGL API that allows direct access to the GPU for high-performance, hardware-accelerated rendering of 2D and 3D graphics.\n",
  "keywords": [
    
  ],
  "articleBody": "Canvas The HTML5 element provides a drawable region in a web page that can be manipulated with JavaScript.\nContext The canvas object allow us to access two type of API or ‘context’.\nThe context2d which uses the CanvasRenderingContext2D API allow us to draw shapes, text, images, and perform pixel manipulation in a rasterized space.\nThe webgl which exposes a low-level WebGL API that allows direct access to the GPU for high-performance, hardware-accelerated rendering of 2D and 3D graphics.\nWhile context2d is simpler and suited for lightweight graphics, webgl enables us to run small programs in the GPU (shaders) which allow us to build more complex visualizations like simulations, games, and 3D rendering by interfacing with shaders and GPU buffers. The WebGL has limitation if we compare with modern OpenGL, but it is still offer a great way to create 3D graphics in the browser.\nTo get thee webgl context, we just need to call getContext on the canvas object.\nconst canvas = document.querySelector(\"#canvas\"); const gl = canvas.getContext(\"webgl\"); Boilerplate To be able to create a webgl web applicatin, we need to do some boilerplate work.\nShaders Shaders are small programs that run on the GPU.\nVertex Shader The vertex shader is the first shader that runs. It is responsible for transforming the vertices of the geometry.\nWe can apply transformations like translation, rotation, and scaling to the vertices in the vertex shader.\nFragment Shader The fragment shader is the second shader that runs. It is responsible for setting each color of the pixels of the geometry. A color could be a simple solid color or a texture (color from an image source).\nShader Variables We can pass data from the JavaScript code to the shaders using variables. We can also pass data from the vertex shader to the fragment shader using special variables called varyings.\nUniforms Uniforms are variables that are passed from the JavaScript code to the shaders. They are constant for the entire shader program. They are per-primitive parameters. They are constant during an entire draw call.\nAttributes Attributes are per-vertex values. Often holding the model matrix, normals, colors, UV coordinates, etc.\nVarying They vary from pixel to pixel. They are per-fragment (aka per-pixel) values.\nTODO\nBuffers Buffers are objects that store data in the GPU memory.\nA complex 3D object normally is represented by a mesh which is made of a set of triangles. Each triangle is made of 3 vertices. Each vertex has a position, a normal, and a color.\nIf we have too many repeated vertices, we can use the BufferAttribute to store the vertices in a more efficient way using indices.\nMaterials Materials are objects that store the properties of the surface of the 3D object. They are used to define the color of the object, the texture, the shininess, etc.\nLight Light is a property of the material that defines how the material reacts to light.\nThe Phong lighting model is a popular model that defines the light of a material.\nTextures Textures are images that are used to color the surface of the 3D objects. We use the uv coordinates to map the texture to the surface of the 3D object.\nThe uv coordinates are a pair of numbers (x, y) that range from 0 to 1. The u coordinate is the x coordinate and the v coordinate is the y coordinate.\nThe work of the fragment shader is to take the uv coordinates of each pixel of the triangle and sample the color of the texture at that position.\nShadow TODO\nReflection TODO\nRefraction TODO\nArchitecture We have multiple objects that we need to organize in the codebase. Let’s go over the main ones:\nScene The scene is the collection of all the 3D objects that we want to render.\nNormally it will hold the objects, the camera, and the lights.\nObject Each object will hold the geometry, the material, and the transformation.\nCamera We can add the camera to the scene to be able to walk around the 3D scene.\nOften we want to use the lookAt function to build the camera matrix.\nClipping To avoid wasting processing power rendering objects that are not visible, like behind the camera or facing away from the camera, we can use the clipping.\nA simple climping technique is to use the normal of the face to check if it is facing the camera or not.\nAnother technique is to build the frustum and check if the object is inside it. The frustum is a pyramid of 6 planes that define the visible area of the camera.\nThe Draw Call The most important function of the WebGL context is the draw call that will trigger the rendering of the scene in the GPU.\nA tipical concern is to keep the number of draw calls to a minimum. Each draw means running the shaders and setting the uniforms.\nThe Pipeline The pipeline is the sequence of steps that the GPU follows to render the scene.\n",
  "wordCount" : "830",
  "inLanguage": "en",
  "datePublished": "2025-05-21T00:00:00Z",
  "dateModified": "2025-05-21T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://mizerc.github.io/posts/technology/webgl/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "The Mize Collection",
    "logo": {
      "@type": "ImageObject",
      "url": "https://mizerc.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<link rel="stylesheet" href="https://mizerc.github.io/custom.css">

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://mizerc.github.io/" accesskey="h" title="The Mize Collection (Alt + H)">The Mize Collection</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://mizerc.github.io/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://mizerc.github.io/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      WebGL
    </h1>
    <hr>
  </header> 
  <div class="post-content"><h1 id="canvas">Canvas<a hidden class="anchor" aria-hidden="true" href="#canvas">#</a></h1>
<p>The HTML5 <code>&lt;canvas&gt;</code> element provides a drawable region in a web page that can be manipulated with JavaScript.</p>
<h2 id="context">Context<a hidden class="anchor" aria-hidden="true" href="#context">#</a></h2>
<p>The canvas object allow us to access two type of API or &lsquo;context&rsquo;.</p>
<p>The <code>context2d</code> which uses the <code>CanvasRenderingContext2D</code> API allow us to draw shapes, text, images, and perform pixel manipulation in a rasterized space.</p>
<p>The <code>webgl</code> which exposes a low-level WebGL API that allows direct access to the GPU for high-performance, hardware-accelerated rendering of 2D and 3D graphics.</p>
<p>While context2d is simpler and suited for lightweight graphics, webgl enables us to run small programs in the GPU (shaders) which allow us to build more complex visualizations like simulations, games, and 3D rendering by interfacing with shaders and GPU buffers.
The WebGL has limitation if we compare with modern OpenGL, but it is still offer a great way to create 3D graphics in the browser.</p>
<p>To get thee webgl context, we just need to call getContext on the canvas object.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>const canvas = document.querySelector(&#34;#canvas&#34;);
</span></span><span style="display:flex;"><span>const gl = canvas.getContext(&#34;webgl&#34;);
</span></span></code></pre></div><h2 id="boilerplate">Boilerplate<a hidden class="anchor" aria-hidden="true" href="#boilerplate">#</a></h2>
<p>To be able to create a webgl web applicatin, we need to do some boilerplate work.</p>
<h2 id="shaders">Shaders<a hidden class="anchor" aria-hidden="true" href="#shaders">#</a></h2>
<p>Shaders are small programs that run on the GPU.</p>
<h3 id="vertex-shader">Vertex Shader<a hidden class="anchor" aria-hidden="true" href="#vertex-shader">#</a></h3>
<p>The vertex shader is the first shader that runs. It is responsible for transforming the vertices of the geometry.</p>
<p>We can apply transformations like translation, rotation, and scaling to the vertices in the vertex shader.</p>
<h3 id="fragment-shader">Fragment Shader<a hidden class="anchor" aria-hidden="true" href="#fragment-shader">#</a></h3>
<p>The fragment shader is the second shader that runs. It is responsible for setting each color of the pixels of the geometry. A color could be a simple solid color or a texture (color from an image source).</p>
<h3 id="shader-variables">Shader Variables<a hidden class="anchor" aria-hidden="true" href="#shader-variables">#</a></h3>
<p>We can pass data from the JavaScript code to the shaders using variables. We can also pass data from the vertex shader to the fragment shader using special variables called varyings.</p>
<h4 id="uniforms">Uniforms<a hidden class="anchor" aria-hidden="true" href="#uniforms">#</a></h4>
<p>Uniforms are variables that are passed from the JavaScript code to the shaders.
They are constant for the entire shader program.
They are per-primitive parameters.
They are constant during an entire draw call.</p>
<h4 id="attributes">Attributes<a hidden class="anchor" aria-hidden="true" href="#attributes">#</a></h4>
<p>Attributes are per-vertex values.
Often holding the model matrix, normals, colors, UV coordinates, etc.</p>
<h4 id="varying">Varying<a hidden class="anchor" aria-hidden="true" href="#varying">#</a></h4>
<p>They vary from pixel to pixel.
They are per-fragment (aka per-pixel) values.</p>
<p>TODO</p>
<h2 id="buffers">Buffers<a hidden class="anchor" aria-hidden="true" href="#buffers">#</a></h2>
<p>Buffers are objects that store data in the GPU memory.</p>
<p>A complex 3D object normally is represented by a mesh which is made of a set of triangles. Each triangle is made of 3 vertices. Each vertex has a position, a normal, and a color.</p>
<p>If we have too many repeated vertices, we can use the <code>BufferAttribute</code> to store the vertices in a more efficient way using indices.</p>
<h2 id="materials">Materials<a hidden class="anchor" aria-hidden="true" href="#materials">#</a></h2>
<p>Materials are objects that store the properties of the surface of the 3D object. They are used to define the color of the object, the texture, the shininess, etc.</p>
<h3 id="light">Light<a hidden class="anchor" aria-hidden="true" href="#light">#</a></h3>
<p>Light is a property of the material that defines how the material reacts to light.</p>
<p>The Phong lighting model is a popular model that defines the light of a material.</p>
<h3 id="textures">Textures<a hidden class="anchor" aria-hidden="true" href="#textures">#</a></h3>
<p>Textures are images that are used to color the surface of the 3D objects. We use the <code>uv</code> coordinates to map the texture to the surface of the 3D object.</p>
<p>The <code>uv</code> coordinates are a pair of numbers (x, y) that range from 0 to 1. The <code>u</code> coordinate is the x coordinate and the <code>v</code> coordinate is the y coordinate.</p>
<p>The work of the fragment shader is to take the <code>uv</code> coordinates of each pixel of the triangle and sample the color of the texture at that position.</p>
<h3 id="shadow">Shadow<a hidden class="anchor" aria-hidden="true" href="#shadow">#</a></h3>
<p>TODO</p>
<h2 id="reflection">Reflection<a hidden class="anchor" aria-hidden="true" href="#reflection">#</a></h2>
<p>TODO</p>
<h2 id="refraction">Refraction<a hidden class="anchor" aria-hidden="true" href="#refraction">#</a></h2>
<p>TODO</p>
<h2 id="architecture">Architecture<a hidden class="anchor" aria-hidden="true" href="#architecture">#</a></h2>
<p>We have multiple objects that we need to organize in the codebase. Let&rsquo;s go over the main ones:</p>
<h3 id="scene">Scene<a hidden class="anchor" aria-hidden="true" href="#scene">#</a></h3>
<p>The scene is the collection of all the 3D objects that we want to render.</p>
<p>Normally it will hold the objects, the camera, and the lights.</p>
<h3 id="object">Object<a hidden class="anchor" aria-hidden="true" href="#object">#</a></h3>
<p>Each object will hold the geometry, the material, and the transformation.</p>
<h3 id="camera">Camera<a hidden class="anchor" aria-hidden="true" href="#camera">#</a></h3>
<p>We can add the camera to the scene to be able to walk around the 3D scene.</p>
<p>Often we want to use the lookAt function to build the camera matrix.</p>
<h2 id="clipping">Clipping<a hidden class="anchor" aria-hidden="true" href="#clipping">#</a></h2>
<p>To avoid wasting processing power rendering objects that are not visible, like behind the camera or facing away from the camera, we can use the clipping.</p>
<p>A simple climping technique is to use the normal of the face to check if it is facing the camera or not.</p>
<p>Another technique is to build the frustum and check if the object is inside it. The frustum is a pyramid of 6 planes that define the visible area of the camera.</p>
<h2 id="the-draw-call">The Draw Call<a hidden class="anchor" aria-hidden="true" href="#the-draw-call">#</a></h2>
<p>The most important function of the WebGL context is the draw call that will trigger the rendering of the scene in the GPU.</p>
<p>A tipical concern is to keep the number of draw calls to a minimum. Each draw means running the shaders and setting the uniforms.</p>
<h2 id="the-pipeline">The Pipeline<a hidden class="anchor" aria-hidden="true" href="#the-pipeline">#</a></h2>
<p>The pipeline is the sequence of steps that the GPU follows to render the scene.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://mizerc.github.io/">The Mize Collection</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
